---
title: "Lifetime"
# categories:
#   - Blog
tags: [rust]

# toc: true
# toc_sticky: true
# toc_label: "페이지 목차"
---

* 모든 참조에는 수명이 있다
* 참조하는 값보다 오래 지속되어서는 안된다
* 수명은 컴파일러가 유추한다
* 직접 수명을 할당할 수 없다
* 명시적 수명 주석은 모호성이 있는 곳에 제약을 만든다

## 컴파일 에러
```rust
#[derive(Debug)]
struct Point(i32, i32);

// &Point를 반환하는데
// 컴파일러는 p1과 p2 중에 어느 것을 반환할 지 알 수 없다
// --> 반환 레퍼런스의 수명을 유추할 수 없다
fn left_most(p1: &Point, p2: &Point) -> &Point {
    if p1.0 < p2.0 {
        p1
    } else {
        p2
    }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p2: Point = Point(20, 20);

    // 컴파일러가 p3의 수명을 유추할 수 없다
    let p3: &Point = left_most(&p1, &p2);

    println!("p3: {p3:?}");
}
```

## 에러 수정: explicit lifetime annotations
```rust
fn left_most<'a>(p1: &'a Point, p2: &'a Point) -> &'a Point {
    if p1.0 < p2.0 {
        p1
    } else {
        p2
    }
}
```

## 표기법
```rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```


## 해석
* (의도) 리턴 참조 유효 조건: 리턴 시에 두 개의 input 참조가 유효
* input 참조 x와 y는 수명이 'a 이다. 즉 같은 수명이다
* 그러나 실제 호출 시 'a는 참조 X와 Y 중에 작은 범위가 된다
* 함수의 return 참조는 수명이 'a 보다 작거나 같아야 한다
* borrow checker는 input과 return 참조가 이 기준에 만족하지 않으면 reject 한다
* input 참조 또는 return 참조의 수명을 변경하는 것이 아니다!!!
* lifetime annotations는 함수 계약의 일부분

```rust
// 모든(input, return) 참조는 lifetime이 동일하다
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

## 컴파일 OK
* 'a는 str1과 str2 중에 더 작은 str2의 수명
* result가 str2의 수명과 동일하므로 OK

```rust
fn main() {
    let str1 = String::from("long string is long");
    {
        let str2 = String::from("xyz");
        let result = longest(str1.as_str(), str2.as_str());
        println!("The longest string is {result}");
    }
}
```

## 컴파일 NOK
* 'a는 str1과 str2 중에 더 작은 str2의 수명
* result가 str1의 수명과 동일하다
* input 참조가 리턴 참조보다 수명이 길다 --> fail

```rust
fn main() {
    let str1 = String::from("long string is long");
    let result;
    {
        let str2 = String::from("xyz");
        result = longest(str1.as_str(), str2.as_str());
    }
    println!("The longest string is {result}");
}
```

## Struct 정의에서 explicit lifetime annotations
* structure 내의 모든 참조 field는 lifetime annotation이 필요하다
* 아래 코드에서 'a가 없으면 컴파일 에러 발생
* struct의 part 필드가 참조하는 값은 struct보다 오래 살아야 한다

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}```
